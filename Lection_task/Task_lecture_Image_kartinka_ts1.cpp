#pragma once // Директива предпроцессора, которая защищает от повторного включения(include) заголовочного файла в программе
#include <iostream> // iostream = input(ввод) out(вывод) stream(поток)
#include <ctime> // Объяснил в main.cpp
#include <fstream> // Нужна для записи в файл и из файла (запись ещё не реализовал)
#include <string> /* Библиотека string добавляет класс string(строка), который представляет собой массив char(символов).
Так как string это класс, у него есть множество методов(Метод-функция в классе), позволяющих удобно работать со строками*/
using namespace std;



class Image {
private: /* Тут писать квалификатор доступа private не обязательно, поскольку если поля или методы в классе объявлены
вне public или protected, то они автоматически становятся private, но для наглядности я написал*/
    int mx; // Поле 
    int my; // Поле
    int** data; // Поле

public:
    Image(int tmx, int tmy) {
        mx = tmx; /* Здесь мы говорим, что у экземпляра(объекта, инстанса) класса поле mx будет равняться значению,
        которое мы передали в конструктор. При этом необходимо упомянуть, что возможно такое:

        class Image {
        private:
          int mx;
          int my;
          int **data;
        }
        public:
          Image(int mx, int my){
            Как ты видишь имя полей совпадают с именами переменных mx и my, которые мы передаём в конструктор.
            Мы не можем написать mx=mx; и my=my;
            Для таких случаев можно использовать указатель this(этот), который означает, что мы имеем ввиду
            поле ЭТОГО класса, т.е в таком случае продолжение будет таким:
            this->mx = mx;
            this->my = my;

          }
        */

        my = tmy; // Аналогично

        /*Три строки ниже это создание двумерного массива.
        Поле data имеет тип **data. Вспомним, что одномерный массив имеет тип *<название_типа>, тут всё по аналогии.
        Что такое двумерный массив? Создание двумерного массива происходит в два этапа:
        1) Создание одного одномерного массива 
        2) Создание в каждой ячейке созданного одномерного массива по ещё одному одномерному массиву

        Это можно представить так, как я прислал тебе на картинке

        Оператор new выделяет память, сравнение C И С++:
        Image *img = (*Image)malloc(sizeof(Image));
        free(img);

        Image *img = new Image;
        delete img; 
        */
        data = new int* [my];        
        for (int i = 0; i < my; i++)  
            data[i] = new int[mx];    

        /* Следующие 3 строки- заполнение массива случайными числами, используя функцию rand()
        (Помним про то что мы задали семя рандома ранее). После rand() я пишу % 10 чтобы заполнить числами от 0 до 9*/
        for (int i = 0; i < mx; i++) {
            for (int j = 0; j < my; j++)
                data[i][j] = rand() % 10; 
        }
        cout << "Constructor is called" << endl;
    }
    /*Деструктор класса вызывается в момент удаления объекта класса (Например, при завершении работы программы
    или когда объект был создан ЛОКАЛЬНО внутри какой-то ФУНКЦИИ/МЕТОДА и происходит выход из этой функции.
    Причём, стоит отметить, что деструктор ниже используется чтобы очистить память, данную под массив, НО!
    В описанном выше случае при завершении работы программы, она сама в состоянии почистить всю память, но
    если случай второй, то произойдёт выход из функции, удалится экземпляр класса, но массив останется висеть в памяти
    если не создан деструктор)*/
    ~Image() {
        for (int i = 0; i < my; i++) 
            delete[] data[i];
        delete[] data;
        /* Тут удаляется каждый одномерный массив, находящийся в ячейках первого одномерного
        массива, а затем сам первоначальный массив*/
    }
    
    // Геттер, предназначение которого я описал выше, просто возвращает значение поля mx
    int getMx() {
        return mx;
    }
    // Аналогичный геттер, но только с my
    int getMy() {
        return my;
    }
    // Функция show(показать), выводящая на экран "изображение", в данном случае двумерный массив в виде матрицы, углубляться не буду 
    void show() {
        for (int i = 0; i < my; i++) {
            for (int j = 0; j < mx; j++)
                cout << data[i][j] << " ";
            cout << endl;
        }
        cout << endl << endl;
    }
    // Ещё один геттер, принимающий 2 параметра, возвращающий значение("цвет") ячейки двумерного массива по переданным индексам
    int get(int x, int y) {
        return data[x][y];
    }
    /* Сеттер, принимающий "координаты" ячейки и "цвет(в данном случае под цветом принимается число)" и меняющий значение
    цвета в ячейке двумерного массива объекта класса */
    void set(int x, int y, int color) {
        data[x][y] = color;
    }
    /* Метод copy(копирования), который должен скопировать изображение.
    В С++ есть такая вещь как ссылки, которые являются синтаксическим сахаром по отношению к указателям, углубляться не буду
    Так вот, метод copy принимает на вход ссылку(обозначается она &) на stream(источник) и destination(назначение),
    затем все поля источника запихиваются в поля назначения, при этом просто так массивы нельзя приравнять, иначе это будут
    не копии, а просто массив назначения будет указывать на ту же область памяти что и источника и они будут меняться вместе,
    что нам не нужно*/
    void copy(Image& stream, Image& destination) {
        destination.mx = stream.mx; 
        destination.my = stream.my;
        for (int i = 0; i < sizeof(stream.data) / sizeof(int); i++) { // Узнаю длину массива путём деления размера массива на размер типа, из которого массив состоит
            for (int j = 0; j < sizeof(stream.data) / sizeof(int); j++)
                destination.data[i][j] = stream.data[i][j];
        }
    }
    /* Метод compare(сравнение) сравнивает поля двух экземпляров класса и возвращает 1 если первое обработанное значение
    из полей экземпляра а > поля b, -1 если меньше и 0 если экземпляры идентичны*/ 
    int compare(Image& a, Image& b) {
      if (a.mx != b.mx || a.my != b.my){
        if(a.mx > b.mx || a.my > b.my)
          return 1;
        else
          return -1;
      }
      for (int i = 0; i < sizeof(a.data) / sizeof(int); i++) {
          for (int j = 0; j < sizeof(b.data) / sizeof(int); j++)
              if (a.data[i][j] != b.data[i][j]) {
                  if (a.data[i][j] > b.data[i][j])
                      return 1;
                  else
                      return -1;
              }
      }
      return 0;
    }
    /*    Пример использования:
    У нас есть класс учеников школы, у каждого ученика свой номер в журнале. Если объявить статическое поле, 
    отвечающую за номер ученика, и обычное поле, то можно прописать её присвоение и увеличение в конструкторе класса.
    Тогда при каждом создании экземпляра класса(ученика), можно будет присваивать обычному полю значение статического,
    из-за чего на этапе создания экземпляров класса у каждого ученика будет свой порядковый номер

     */
    static void fillHorisontalLine(Image& img, int line, int* pixArray);
};
/* Метод fillHorisontalLine(ЗаполнитьГоризонтальнуюЛинию), принимает на вход ссылку на экземпляр класса Image,
порядковый номер линии(начиная от 0, так как это массив) и массив значений, на которые надо поменять значения в линии line*/
void Image::fillHorisontalLine(Image& img, int line, int* pixArray) {
    for (int i = 0; i < img.mx; i++)
        img.data[line][i] = pixArray[i];
}


int main() {
    srand(time(NULL)); /* Говорят, что в компьютере не существует рандома, это так, так как он использует только 0 и 1
    в своей работе, по этому машинный рандом называют детерменированным. Функция srand() генерирует семя рандома, без 
    её использования каждый раз будет отображаться одинаковые псевдослучайные числа. В данном случае семя рандома 
    генерируется с помощью функции time() из библиотеки <ctime>(я её включаю в файле Image.h),
     которая выдаёт время с момента запуска процесса, поэтому числа будут разные*/

     
    Image a(10, 10); // Создание экземпляра класса Image с именем а
    cout << "1st img: " << endl;
    a.show(); // Вызываем метод, отображающий "изображение", созданное конструктором на экран
    int pixArray[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // Создал массив, которым буду заполнять горизонтальную линию
    Image b(10, 10); // Второй экземпляр класса
    cout << "2nd img: " << endl;
    b.show(); // Вывод второго экземпляра
    cout << "Compare a, b :" << a.compare(a, b) << endl; // Выводим результат сравнения двух инстансов класса
    a.copy(a, b); // Копируем содержимое класса а в класс b (метод тоже следовало сделать статическим, а то странно выглядит)
    cout << "A copied to B" << endl;
    b.show(); // Вывод второго экземпляра после копирования
    cout << "2nd img after copying" << endl;
    cout << "Compare a, b :" <<  a.compare(a, b) << endl; // Вывод результата сравнения двух экземпляров (должно показать 0)
    Image::fillHorisontalLine(a, 0, pixArray); // Заполняем нулевую линию экземпляра а массивом pixArray, созданным выше
    cout << "Fill 0 line at A image: " << endl;
    a.show(); // Выводим экземпляр класса а
    cout << endl;
    cout << "Get 0, 0: " << a.get(0, 0) << endl; // Тестируем геттер, который выдаёт значение в ячейке [0][0]
    a.set(0, 0, 5); // Записываем в ячейку [0][0] значение 5
    cout << "Set 0, 0: " << endl;
    a.show(); // Показываем экземпляр а
    return 0;
}