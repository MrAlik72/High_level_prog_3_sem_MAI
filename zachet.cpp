1 Алгоритмы в библиотеке stl.
2 Конструктор. Конструктор по умолчанию, конструктор копирования. Оператор присваивания.
3 Контейнеры в библиотеке stl.
4 Указатели на функции. Функциональные объекты и Лямбда выражения
5 Механизмы синхронизации и параллельное выполнение в стандартной библиотеке С++11/14
6 Обработка исключительных ситуаций - исключения.
7 Обработка ошибок в стиле С и в стиле С++. Коды возврата и исключения.
8 Объектно-ориентированное программирование. Наследование, множественное наследование и полиморфизм в C++.
9 Перегрузка операторов в C++. Операторы вывода в поток.
10 Перегрузка операторов в C++. Оператор присваивания. Арифметические операторы.
11 Потоки ввода вывода в stl
12 Потоки и параллельное выполнение в стандартной библиотеке С++11/14
13 Преобразование типов в C++. Явное и неявное преобразование типов.
14 Проектирование программ - инкапсуляция
15 Пространства имен. Области видимости в C++.
16 Расширения языка C++11. Auto. Nultr. Рендж базед циклы
17 Темплейты. Пример шаблонный функции.
18 Темплейты. Пример шаблонного класса
19 Указатели на функции и их использование совместно с массивами и структурами.
20 Умные указатели в библиотеке stl.
21 Функции. Передача параметров. По значению. По ссылке. По указателю. Использование const с параметрами.
22 lvalue и rvalue. Move семантика.
23 Структура программы в java. Работа с пакетами.
24 ООП в java. Класс, наследование, полиморфизм, интерфейсы
25 Контейнерные классы в java
26 Generic-и в java
27 Инкапсуляция.





1)Стандартная библиотека шаблонов (сокр. «STL» от «Standard Template Library») — это часть Стандартной библиотеки С++,
которая содержит набор шаблонов контейнерных классов (например, std::vector и std::array), алгоритмов и итераторов.
Изначально она была сторонней разработкой, но позже была включена в Стандартную библиотеку С++.
Если вам нужен какой-нибудь общий класс или алгоритм, то, скорее всего, в Стандартной библиотеке шаблонов он уже есть.
Положительным моментом является то, что вы можете использовать эти классы без необходимости писать и отлаживать их самостоятельно (и разбираться в том, как они реализованы).
Кроме того, вы получаете достаточно эффективные (и уже много раз протестированные) версии этих классов.
Недостатком является то, что не всё так просто/очевидно с функционалом Стандартной библиотеки шаблонов и это может быть несколько непонятно новичку,
так как большинство классов на самом деле являются шаблонами классов.
Алгоритмы STL реализованы в виде глобальных функций, которые работают с использованием итераторов. Это означает, что каждый алгоритм нужно реализовать всего лишь один раз,
и он будет работать со всеми контейнерами, которые предоставляют набор итераторов (включая и ваши собственные (пользовательские) контейнерные классы).
Хотя это имеет огромный потенциал и предоставляет возможность быстро писать сложный код,
у алгоритмов также есть и «тёмная сторона» — некоторая комбинация алгоритмов и типов контейнеров может не работать/работать с плохой производительностью/вызывать бесконечные циклы,
поэтому следует быть осторожным.

Алгоритмы min_element() и max_element() находят минимальный и максимальный элементы в контейнере:
#include <iostream>
#include <list>
#include <algorithm>
int main()
{
    std::list<int> li;
    for (int nCount=0; nCount < 5; ++nCount)
        li.push_back(nCount);
    std::list<int>::const_iterator it; // объявляем итератор
    it = min_element(li.begin(), li.end());
        std::cout << *it << ' ';
    it = max_element(li.begin(), li.end());
        std::cout << *it << ' ';
    std::cout << '\n';
}
Результат выполнения программы:0 4


Алгоритмы find() и list::insert()
В следующем примере мы используем алгоритм find(), чтобы найти определенное значение в списке, а затем используем функцию list::insert() для добавления нового значения в список
#include <iostream>
#include <list>
#include <algorithm>
int main()
{
    std::list<int> li;
    for (int nCount=0; nCount < 5; ++nCount)
        li.push_back(nCount);

    std::list<int>::iterator it; // объявляем итератор
    it = find(li.begin(), li.end(), 2); // ищем в списке число 2
    li.insert(it, 7); // используем алгоритм list::insert() для добавления числа 7 перед числом 2
    for (it = li.begin(); it != li.end(); ++it) // выводим с помощью цикла и итератора элементы списка
        std::cout << *it << ' ';

    std::cout << '\n';
}
Результат выполнения программы:
0 1 7 2 3 4


Алгоритмы sort() и reverse()
В следующем примере мы отсортируем весь вектор, выведем отсортированные элементы, а затем выведем их в обратном порядке:
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{

    std::vector<int> vect;
    vect.push_back(4);
    vect.push_back(8);
    vect.push_back(-3);
    vect.push_back(3);
    vect.push_back(-8);
    vect.push_back(12);
    vect.push_back(5);

    std::sort(vect.begin(), vect.end()); // выполняем сортировку элементов вектора

    std::vector<int>::const_iterator it; // объявляем итератор
    for (it = vect.begin(); it != vect.end(); ++it) // выводим с помощью цикла и итератора элементы вектора
        std::cout << *it << ' ';

    std::cout << '\n';

    std::reverse(vect.begin(), vect.end()); // сортируем элементы вектора в обратную сторону

    for (it = vect.begin(); it != vect.end(); ++it) // выводим с помощью цикла и итератора элементы вектора
        std::cout << *it << ' ';

    std::cout << '\n';
}
Результат выполнения программы:

-8 -3 3 4 5 8 12
12 8 5 4 3 -3 -8

Обратите внимание, общий алгоритм sort() не работает с вектором, у вектора есть свой собственный метод sort(), который, в данном случае, является более эффективным.




2)Конструктор — это особый тип метода класса, который автоматически вызывается при создании объекта этого же класса.
Конструкторы обычно используются для инициализации переменных-членов класса значениями, которые предоставлены по умолчанию/пользователем, или для выполнения любых шагов настройки, необходимых для используемого класса (например, открыть определенный файл или базу данных).
В отличие от обычных методов, конструкторы имеют определенные правила их именования:
---конструкторы всегда должны иметь то же имя, что и класс (учитываются верхний и нижний регистры);
---конструкторы не имеют типа возврата (даже void).
Обратите внимание, конструкторы предназначены только для выполнения инициализации.
Не следует пытаться вызывать конструктор для повторной инициализации существующего объекта.
Хотя это может скомпилироваться без ошибок, результаты могут получиться неожиданные (компилятор создаст временный объект, а затем удалит его).

******Конструкторы по умолчанию*****

Конструктор, который не имеет параметров (или содержит параметры, которые все имеют значения по умолчанию), называется конструктором по умолчанию.
Он вызывается, если пользователем не указаны значения для инициализации. Например:

#include <iostream>

class Fraction
{
private:
    int m_numerator;
    int m_denominator;

public:
    Fraction() // конструктор по умолчанию
    {
         m_numerator = 0;
         m_denominator = 1;
    }

    int getNumerator() { return m_numerator; }
    int getDenominator() { return m_denominator; }
    double getValue() { return static_cast<double>(m_numerator) / m_denominator; }
};

int main()
{
    Fraction drob; // так как нет никаких аргументов, то вызывается конструктор по умолчанию Fraction()
    std::cout << drob.getNumerator() << "/" << drob.getDenominator() << '\n';

    return 0;
  }
Этот класс содержит дробь в виде отдельных значений типа int. Конструктор по умолчанию называется Fraction (как и класс).
Поскольку мы создали объект класса Fraction без аргументов, то конструктор по умолчанию сработал сразу же после выделения памяти для объекта, и инициализировал наш объект.

Результат выполнения программы:  0/1
Обратите внимание, наш числитель (m_numerator) и знаменатель (m_denominator) были инициализированы значениями, которые мы задали в конструкторе по умолчанию!
Это настолько полезная особенность, что почти каждый класс имеет свой конструктор по умолчанию.
Без него значениями нашего числителя и знаменателя был бы мусор до тех пор, пока мы явно не присвоили бы им нормальные значения.


******Конструктор копирования и оператор присваивания копированием******

Конструктор копирования используется для инициализации класса путем создания копии необходимого объекта.
Оператор присваивания копированием (или «копирующее присваивание») используется для копирования одного класса в другой (существующий) класс.
По умолчанию язык C++ автоматически предоставляет конструктор копирования и оператор присваивания копированием, если вы не предоставили их сами.
Предоставляемые компилятором функции выполняют поверхностное копирование, что может вызывать проблемы у классов, которые работают с динамически выделенной памятью.
Одним из вариантов решения таких проблем является переопределение конструктора копирования и оператора присваивания копированием для выполнения глубокого копирования.

#include <iostream>

template<class T>
class Auto_ptr3
{
	T* m_ptr;
public:
	Auto_ptr3(T* ptr = nullptr)
		:m_ptr(ptr)
	{
	}

	~Auto_ptr3()
	{
		delete m_ptr;
	}

	// Конструктор копирования, который выполняет глубокое копирование x.m_ptr в m_ptr
	Auto_ptr3(const Auto_ptr3& x)
	{
		m_ptr = new T;
		*m_ptr = *x.m_ptr;
	}

	// Оператор присваивания копированием, который выполняет глубокое копирование x.m_ptr в m_ptr
	Auto_ptr3& operator=(const Auto_ptr3& x)
	{
		// Проверка на самоприсваивание
		if (&x == this)
			return *this;

		// Удаляем всё, что к этому моменту может хранить указатель
		delete m_ptr;

		// Копируем передаваемый объект
		m_ptr = new T;
		*m_ptr = *x.m_ptr;

		return *this;
	}

	T& operator*() const { return *m_ptr; }
	T* operator->() const { return m_ptr; }
	bool isNull() const { return m_ptr == nullptr; }
};

class Item
{
public:
	Item() { std::cout << "Item acquired\n"; }
	~Item() { std::cout << "Item destroyed\n"; }
};

Auto_ptr3<Item> generateItem()
{
	Auto_ptr3<Item> item(new Item);
	return item; // это возвращаемое значение приведет к вызову конструктора копирования
}

int main()
{
	Auto_ptr3<Item> mainItem;
	mainItem = generateItem(); // эта операция присваивания приведет к вызову оператора присваивания копированием

	return 0;
}
В программе, приведенной выше, мы используем функцию generateItem() для создания инкапсулированного умного указателя Item,
который затем передается обратно в функцию main(). В функции main() мы присваиваем его объекту mainItem.

Результат выполнения программы:

Item acquired
Item acquired
Item destroyed
Item acquired
Item destroyed
Item destroyed

*****Конструктор перемещения и оператор присваивания перемещением******

Определение конструктора перемещения и оператора присваивания перемещением выполняется аналогично определению конструктора копирования и оператора присваивания копированием.
Однако, в то время как функции с копированием принимают в качестве параметра константную ссылку l-value, функции с перемещением принимают в качестве параметра неконстантную ссылку r-value.

#include <iostream>

template<class T>
class Auto_ptr4
{
	T* m_ptr;
public:
	Auto_ptr4(T* ptr = nullptr)
		:m_ptr(ptr)
	{
	}

	~Auto_ptr4()
	{
		delete m_ptr;
	}

	// Конструктор копирования, который выполняет глубокое копирование x.m_ptr в m_ptr
	Auto_ptr4(const Auto_ptr4& x)
	{
		m_ptr = new T;
		*m_ptr = *x.m_ptr;
	}

	// Конструктор перемещения, который передает право собственности на x.m_ptr в m_ptr
	Auto_ptr4(Auto_ptr4&& x)
		: m_ptr(x.m_ptr)
	{
		x.m_ptr = nullptr; // мы поговорим об этом чуть позже
	}

	// Оператор присваивания копированием, который выполняет глубокое копирование x.m_ptr в m_ptr
	Auto_ptr4& operator=(const Auto_ptr4& x)
	{
		// Проверка на самоприсваивание
		if (&x == this)
			return *this;

		// Удаляем всё, что к этому моменту может хранить указатель
		delete m_ptr;

		// Копируем передаваемый объект
		m_ptr = new T;
		*m_ptr = *x.m_ptr;

		return *this;
	}

	// Оператор присваивания перемещением, который передает право собственности на x.m_ptr в m_ptr
	Auto_ptr4& operator=(Auto_ptr4&& x)
	{
		// Проверка на самоприсваивание
		if (&x == this)
			return *this;

		// Удаляем всё, что к этому моменту может хранить указатель
		delete m_ptr;

		// Передаем право собственности на x.m_ptr в m_ptr
		m_ptr = x.m_ptr;
		x.m_ptr = nullptr; // мы поговорим об этом чуть позже

		return *this;
	}

	T& operator*() const { return *m_ptr; }
	T* operator->() const { return m_ptr; }
	bool isNull() const { return m_ptr == nullptr; }
};

class Item
{
public:
	Item() { std::cout << "Item acquired\n"; }
	~Item() { std::cout << "Item destroyed\n"; }
};

Auto_ptr4<Item> generateItem()
{
	Auto_ptr4<Item> item(new Item);
	return item; // это возвращаемое значение приведет к вызову конструктора перемещения
}

int main()
{
	Auto_ptr4<Item> mainItem;
	mainItem = generateItem(); // эта операция присваивания приведет к вызову оператора присваивания перемещением

	return 0;
}

Всё просто! Вместо выполнения глубокого копирования исходного объекта в неявный объект, мы просто перемещаем (воруем) ресурсы исходного объекта.
Под этим подразумевается поверхностное копирование указателя на исходный объект в неявный (временный) объект,
а затем присваивание исходному указателю значения null (точнее nullptr) и в конце удаление неявного объекта.

Результат выполнения программы:
Item acquired
Item destroyed





3)Контейнеры в библиотеке stl.

Наиболее часто используемым функционалом библиотеки STL являются контейнерные классы (или как их еще называют — «контейнеры»).
Библиотека STL содержит много разных контейнерных классов, которые можно использовать в разных ситуациях.
Если говорить в общем, то контейнеры STL делятся на три основные категории:
---последовательные;
---ассоциативные;
---адаптеры.

******Последовательные контейнеры*****

Последовательные контейнеры (или «контейнеры последовательности») — это контейнерные классы, элементы которых находятся в последовательности.
Их определяющей характеристикой является то, что вы можете добавить свой элемент в любое место контейнера.
Наиболее распространенным примером последовательного контейнера является массив: при добавлении 4-х элементов в массив,
эти элементы будут находиться (в массиве) в точно таком же порядке, в котором вы их добавили.
Начиная с C++11, STL содержит 6 контейнеров последовательности:

   std::vector;

   std::deque;

   std::array;

   std::list;

   std::forward_list;

   std::basic_string.

Класс vector (или просто «вектор») — это динамический массив, способный увеличиваться по мере необходимости для содержания всех своих элементов.
Класс vector обеспечивает произвольный доступ к своим элементам через оператор индексации [], а также поддерживает добавление и удаление элементов.
В следующей программе мы добавляем 5 целых чисел в вектор и с помощью перегруженного оператора индексации [] получаем к ним доступ для их последующего вывода:

#include <iostream>
#include <vector>

int main()
{

    std::vector<int> vect;
    for (int count=0; count < 5; ++count)
        vect.push_back(10 - count); // добавляем числа в конец массива

    for (int index=0; index < vect.size(); ++index)
        std::cout << vect[index] << ' ';

    std::cout << '\n';
}
Результат выполнения программы:
10 9 8 7 6

Класс deque (или просто «дек») — это двусторонняя очередь, реализованная в виде динамического массива, который может расти с обоих концов. Например:

#include <iostream>
#include <deque>

int main()
{
    std::deque<int> deq;
    for (int count=0; count < 4; ++count)
    {
        deq.push_back(count); // вставляем числа в конец массива
        deq.push_front(10 - count); // вставляем числа в начало массива
    }

    for (int index=0; index < deq.size(); ++index)
        std::cout << deq[index] << ' ';

    std::cout << '\n';
}
Результат выполнения программы:
7 8 9 10 0 1 2 3

List (или просто «список») — это двусвязный список, каждый элемент которого содержит 2 указателя: один указывает на следующий элемент списка, а другой — на предыдущий элемент списка.
list предоставляет доступ только к началу и к концу списка — произвольный доступ запрещен.
Если вы хотите найти значение где-то в середине, то вы должны начать с одного конца и перебирать каждый элемент списка до тех пор, пока не найдете то, что ищете.
Преимуществом двусвязного списка является то, что добавление элементов происходит очень быстро, если вы, конечно, знаете, куда хотите добавлять.
Обычно для перебора элементов двусвязного списка используются итераторы.

Хотя о классе string (и wstring) обычно не говорят, как о последовательном контейнере,
но он, по сути, таковым является, поскольку его можно рассматривать как вектор с элементами типа char (или wchar).

****Ассоциативные контейнеры*****

Ассоциативные контейнеры — это контейнерные классы, которые автоматически сортируют все свои элементы (в том числе и те, которые добавляете вы).
По умолчанию ассоциативные контейнеры выполняют сортировку элементов, используя оператор сравнения <.

---set — это контейнер, в котором хранятся только уникальные элементы, и повторения запрещены. Элементы сортируются в соответствии с их значениями.

---multiset — это set, но в котором допускаются повторяющиеся элементы.

---map (или «ассоциативный массив») — это set, в котором каждый элемент является парой «ключ-значение».
«Ключ» используется для сортировки и индексации данных и должен быть уникальным. А «значение» — это фактические данные.

---multimap (или «словарь») — это map, который допускает дублирование ключей.
Все ключи отсортированы в порядке возрастания, и вы можете посмотреть значение по ключу.

*****Адаптеры*****

Адаптеры — это специальные предопределенные контейнерные классы, которые адаптированы для выполнения конкретных заданий.
Самое интересное заключается в том, что вы сами можете выбрать, какой последовательный контейнер должен использовать адаптер.

---stack (стек) — это контейнерный класс, элементы которого работают по принципу LIFO (англ. «Last In, First Out» = «Последним Пришёл, Первым Ушёл»),
т.е. элементы добавляются (вносятся) в конец контейнера и удаляются (выталкиваются) оттуда же (из конца контейнера).
Обычно в стеках используется deque в качестве последовательного контейнера по умолчанию (что немного странно, поскольку vector был бы более подходящим вариантом),
но вы также можете использовать vector или list.

---queue (очередь) — это контейнерный класс, элементы которого работают по принципу FIFO (англ. «First In, First Out» = «Первым Пришёл, Первым Ушёл»),
т.е. элементы добавляются (вносятся) в конец контейнера, но удаляются (выталкиваются) из начала контейнера.
По умолчанию в очереди используется deque в качестве последовательного контейнера, но также может использоваться и list.

---priority_queue (очередь с приоритетом) — это тип очереди, в которой все элементы отсортированы (с помощью оператора сравнения <).
При добавлении элемента, он автоматически сортируется.
Элемент с наивысшим приоритетом (самый большой элемент) находится в самом начале очереди с приоритетом, также,
как и удаление элементов выполняется с самого начала очереди с приоритетом.



4)Указатели на функции. Функциональные объекты и Лямбда выражения

*****Указатели на функции*****
Указатель на функцию (function pointer) хранит адрес функции.
По сути указатель на функцию содержит адрес первого байта в памяти, по которому располагается выполняемый код функции.
Самым распространенным указателем на функцию является ее имя. С помощью имени функции можно вызывать ее и получать результат ее работы.
Но также указатель на функцию мы можем определять в виде отдельной переменной с помощью следующего синтаксиса:
  тип (*имя_указателя) (параметры);

Используем указатель на функцию:
#include <iostream>

void hello();
void goodbye();

int main()
{
    void (*message)();

    message=hello;
    message();
    message = goodbye;
    message();

    return 0;
}
void hello()
{
    std::cout << "Hello, World" << std::endl;
}
void goodbye()
{
    std::cout << "Good Bye, World" << std::endl;
}

****Функциональные объекты*****

Функторы в C++ являются сокращением от "функциональные объекты". Функциональный объект является экземпляром класса С++, в котором определён operator().
Если вы определите operator() для C++ класса, то вы получите объект, который действует как функция, но может также хранить состояние.
Например:
#include <iostream>
#include <string>

class SimpleFunctor {
    std::string name_;
public:
    SimpleFunctor(const char *name) : name_(name) {}
    void operator()() { std::cout << "Oh, hello, " << name_ << endl; }
};

int main() {
    SimpleFunctor sf("catonmat");
    sf();  // выводит "Oh, hello, catonmat"
}
Обратите внимание, что мы можем вызывать sf() в функции main, хотя sf является объектом.
Это потому, что в классе SimpleFunctor для него определён operator().

*****Лямбда выражения*****

Лямбда-выражение (или просто «лямбда») в программировании позволяет определить анонимную функцию внутри другой функции.
Возможность сделать функцию вложенной является очень важным преимуществом, так как позволяет избегать как захламления пространства имен лишними объектами,
так и определить функцию как можно ближе к месту её первого использования.
Синтаксис лямбда-выражений является одним из самых странных в языке C++, и вам может потребоваться некоторое время, чтобы к нему привыкнуть.

Лямбда-выражения имеют следующий синтаксис:

[ captureClause ] ( параметры ) -> возвращаемыйТип
{
стейтменты;
}

Поля captureClause и параметры могут быть пустыми, если они не требуются программисту.
Поле возвращаемыйТип является опциональным, и, если его нет, то будет использоваться вывод типа с помощью ключевого слова auto.
Хотя мы ранее уже отмечали, что следует избегать использования вывода типа для возвращаемых значений функций,
в данном контексте подобное использование допускается (поскольку обычно такие функции являются тривиальными).

Также обратите внимание, что лямбда-выражения не имеют имен, поэтому нам и не нужно будет их предоставлять.
Из этого факта следует, что тривиальное определение лямбды может иметь следующий вид:

#include <iostream>

int main()
{
  []() {}; // определяем лямбда-выражение без captureClause, параметров и возвращаемого типа

  return 0;
}

Пример:
#include <algorithm>
#include <array>
#include <iostream>
#include <string_view>

int main()
{
  std::array<std::string_view, 4> arr{ "apple", "banana", "walnut", "lemon" };

  // Определяем функцию непосредственно в том месте, где собираемся её использовать
  auto found{ std::find_if(arr.begin(), arr.end(),
                           [](std::string_view str) // вот наша лямбда, без поля captureClause
                           {
                             return (str.find("nut") != std::string_view::npos);
                           }) };

  if (found == arr.end())
  {
    std::cout << "No nuts\n";
  }
  else
  {
    std::cout << "Found " << *found << '\n';
  }

  return 0;
}
Результат выполнения программы:
Found walnut



5)Механизмы синхронизации и параллельное выполнение в стандартной библиотеке С++11/14



6)Обработка исключительных ситуаций - исключения.

Исключение — это событие при выполнении программы, которое приводит к её ненормальному или неправильному поведению.
Существует два вида исключений:

Аппаратные (структурные, SE-Structured Exception), которые генерируются процессором. К ним относятся, например,
---деление на 0;
---выход за границы массива;
---обращение к невыделенной памяти;
---переполнение разрядной сетки.
Программные, генерируемые операционной системой и прикладными программами – возникают тогда,
когда программа их явно инициирует. Когда встречается аномальная ситуация, та часть программы, которая ее обнаружила,
может сгенерировать, или возбудить, исключение.
Исключения в языке C++ реализованы с помощью 3-х ключевых слов, которые работают в связке друг с другом: throw, try и catch.

****Генерация исключений****

В языке C++ оператор throw используется для сигнализирования о возникновении исключения или ошибки (аналогия тому, когда свистит арбитр).
Сигнализирование о том, что произошло исключение, называется генерацией исключения (или «выбрасыванием исключения»).
Для использования оператора throw применяется ключевое слово throw, а за ним указывается значение любого типа данных,
которое вы хотите задействовать, чтобы сигнализировать об ошибке. Как правило, этим значением является код ошибки,
описание проблемы или настраиваемый класс-исключение. Например:
throw -1; // генерация исключения типа int
throw ENUM_INVALID_INDEX; // генерация исключения типа enum
throw "Can not take square root of negative number"; // генерация исключения типа const char* (строка C-style)
throw dX; // генерация исключения типа double (переменная типа double, которая была определена ранее)
throw MyException("Fatal Error"); // генерация исключения с использованием объекта класса MyException
Каждая из этих строк сигнализирует о том, что возникла какая-то ошибка, которую нужно обработать.

****Поиск исключения****

Выбрасывание исключений — это лишь одна часть процесса обработки исключений.
В языке C++ мы используем ключевое слово try для определения блока стейтментов (так называемого «блока try»).
Блок try действует как наблюдатель в поисках исключений, которые были выброшены каким-либо из операторов в этом же блоке try, например:

try
{
    // Здесь мы пишем стейтменты, которые будут генерировать следующее исключение
    throw -1; // типичный стейтмент throw
}
Обратите внимание, блок try не определяет, КАК мы будем обрабатывать исключение. Он просто сообщает компилятору:
«Эй, если какой-либо из стейтментов внутри этого блока try сгенерирует исключение — поймай его!».

****Обработка исключений****

Фактически, обработка исключений — это работа блока(ов) catch.
Ключевое слово catch используется для определения блока кода (так называемого «блока catch»),
который обрабатывает исключения определенного типа данных.

Вот пример блока catch, который обрабатывает (ловит) исключения типа int:

catch (int a)
{
    // Обрабатываем исключение типа int
    std::cerr << "We caught an int exception with value" << a << '\n';
}
Блоки try и catch работают вместе. Блок try обнаруживает любые исключения, которые были выброшены в нем,
и направляет их в соответствующий блок catch для обработки.
Блок try должен иметь, по крайней мере, один блок catch, который находится сразу же за ним, но также может иметь и несколько блоков catch,
размещенных последовательно (друг за другом).
Как только исключение было поймано блоком try и направлено в блок catch для обработки,
оно считается обработанным (после выполнения кода блока catch), и выполнение программы возобновляется.
Параметры catch работают так же, как и параметры функции,
причем параметры одного блока catch могут быть доступны и в другом блоке catch (который находится за ним).
Исключения фундаментальных типов данных могут быть пойманы по значению (параметром блока catch является значение),
но исключения не фундаментальных типов данных должны быть пойманы по константной ссылке (параметром блока catch является константная ссылка),
дабы избежать ненужного копирования.
Как и в случае с функциями, если параметр не используется в блоке catch, то имя переменной можно не указывать:

catch (double) // примечание: Мы не указываем имя переменной, так как в этом нет надобности (мы её нигде в блоке не используем)
{
    // Обрабатываем исключение типа double здесь
    std::cerr << "We caught an exception of type double" << '\n';
}
Это предотвратит вывод предупреждений компилятора о неиспользуемых переменных.

*****Использование throw, try и catch вместе*****

Вот полная программа, которая использует throw, try и несколько блоков catch:
#include <iostream>
#include <string>

int main()
{
    try
    {
        // Здесь мы пишем стейтменты, которые будут генерировать следующее исключение
        throw -1; // типичный стейтмент throw
    }
    catch (int a)
    {
        // Любые исключения типа int, сгенерированные в блоке try, приведенном выше, обрабатываются здесь
        std::cerr << "We caught an int exception with value: " << a << '\n';
    }
    catch (double) // мы не указываем имя переменной, так как в этом нет надобности (мы её нигде в блоке не используем)
    {
        // Любые исключения типа double, сгенерированные в блоке try, приведенном выше, обрабатываются здесь
        std::cerr << "We caught an exception of type double" << '\n';
    }
    catch (const std::string &str) // ловим исключения по константной ссылке
    {
        // Любые исключения типа std::string, сгенерированные внутри блока try, приведенном выше, обрабатываются здесь
        std::cerr << "We caught an exception of type std::string" << '\n';
    }

    std::cout << "Continuing our way!\n";

    return 0;
}
Результат выполнения программы:
We caught an int exception with value -1
Continuing our way!



7)Обработка ошибок в стиле С и в стиле С++. Коды возврата и исключения.

*****В стиле C++ см. предыдущий вопрос.*******


Хотя C не обеспечивает прямой поддержки обработки ошибок (или обработки исключений),
существуют способы, с помощью которых обработка ошибок может быть осуществлена в C.

*****Глобальная переменная errno****

Когда в C вызывается функция, переменной с именем errno автоматически присваивается код (значение),
который можно использовать для определения типа возникшей ошибки. Это глобальная переменная, указывающая,
что ошибка произошла во время любого вызова функции и определена в заголовочном файле errno.h.
Разные коды (значения) для errno означают разные типы ошибок. Ниже приведен список из нескольких различных значений errno и соответствующего значения:

errno value       Error
1             /* Operation not permitted */
2             /* No such file or directory */
3             /* No such process */
4             /* Interrupted system call */
5             /* I/O error */
6             /* No such device or address */
7             /* Argument list too long */
8             /* Exec format error */
9             /* Bad file number */
10            /* No child processes */
11            /* Try again */
12            /* Out of memory */
13            /* Permission denied */

Реализация C, чтобы увидеть, как значение errno установить в случае любой ошибки в C
#include <stdio.h>
#include <errno.h>

int main()

{
    // Если файл открыт, который не существует,
    // тогда это будет ошибка и соответствующая
    // значение errno будет установлено
    FILE * fp;
    // открываем файл который
    // не существует.
    fp = fopen("GeeksForGeeks.txt", "r");
    printf(" Value of errno: %d\n ", errno);
    return 0;
}
Выход:
Value of errno: 2

****perror () и strerror ()****

Приведенное выше значение errno указывает типы возникших ошибок.
Если требуется показать описание ошибки, то есть две функции, которые можно использовать для отображения текстового сообщения, связанного с errorno.
Функции:

  perror: отображает строку, которую вы передаете ей, затем двоеточие, пробел, а затем текстовое представление текущего значения errno.
  Синтаксис:

      void perror (const char *str)
      str: is a string containing a custom message
      to be printed before the error message itself.

  strerror (): возвращает указатель на текстовое представление текущего значения errno.
  Синтаксис:

      char *strerror (int errnum)
      errnum: is the error number (errno).

Реализация C, чтобы увидеть, как perror () и strerror () функции используются для печати сообщений об ошибках.
      #include <stdio.h>
      #include <errno.h>
      #include <string.h>

      int main ()

      {

          FILE *fp;
          // Если файл открыт, который не существует,
          // тогда это будет ошибка и соответствующая
          // значение errno будет установлено

          fp = fopen(" GeeksForGeeks.txt ", "r");

          // открываем файл который
          // не существует.
          printf("Value of errno: %d\n ", errno);

          printf("The error message is : %s\n",
          strerror(errno));
          perror("Message from perror");
          return 0;

      }
Выход:
Value of errno: 2
The error message is : No such file or directory
Message from perror: No such file or directory




8)Объектно-ориентированное программирование. Наследование, множественное наследование и полиморфизм в C++.

****ООП****

Объекты имеют два основных компонента:
---свойства (например, вес, цвет, размер, прочность, форма и т.д.);
---поведение, которое они могут проявлять (например, открывать что-либо, делать что-то и т.д.).
Свойства и поведение неотделимы друг от друга.

Объектно-ориентированное программирование (сокр. «ООП») предоставляет возможность создавать объекты,
которые объединяют свойства и поведение в самостоятельный союз, который затем можно многоразово использовать.
Это позволяет создавать программы модульным способом, что упрощает не только написание и понимание кода,
но и обеспечивает более высокий уровень возможности повторного использования этого кода.
Объекты также обеспечивают более интуитивный способ работы с данными, позволяя программисту определить,
как он будет взаимодействовать с объектами, и как эти объекты будут взаимодействовать с другими объектами.

****Наследование*****

Наследование в C++ происходит между классами и имеет тип отношений «является».
Класс, от которого наследуют, называется родительским (или «базовым», «суперклассом»), а класс,
который наследует, называется дочерним (или «производным», «подклассом»).
Дочерний класс наследует как поведение (методы), так и свойства (переменные-члены) от родителя (с учетом некоторых ограничений доступа,
которые мы рассмотрим чуть позже). Эти методы и переменные становятся членами дочернего класса.
Поскольку дочерние классы являются полноценными классами, то они могут (конечно) иметь и свои собственные члены.
Сейчас мы это всё рассмотрим детально.

Вот простой класс Human для представления Человека:
#include <string>

class Human
{
public:
    std::string m_name;
    int m_age;

    Human(std::string name = "", int age = 0)
        : m_name(name), m_age(age)
    {
    }

    std::string getName() const { return m_name; }
    int getAge() const { return m_age; }

};
В этом классе мы определили только те члены, которые являются общими для всех объектов этого класса.
Каждый Человек (независимо от пола, профессии и т.д.) имеет Имя и Возраст.
Обратите внимание, в примере, приведенном выше, мы сделали все переменные-члены и методы класса открытыми.

Предположим, что нам нужно написать программу, которая будет отслеживать информацию о баскетболистах.
Мы можем сохранять средний уровень игры баскетболиста и количество очков.

Вот наш незавершенный класс BasketballPlayer:

class BasketballPlayer
{
public:
    double m_gameAverage;
    int m_points;

    BasketballPlayer(double gameAverage = 0.0, int points = 0)
       : m_gameAverage(gameAverage), m_points(points)
    {
    }
};
Также нам нужно знать Имя и Возраст баскетболиста, а эта информация уже у нас есть: она хранится в классе Human.
У нас есть три варианта добавления Имени и Возраста в BasketballPlayer:

---Добавить Имя и Возраст в класс BasketballPlayer непосредственно в качестве членов.
Это плохой вариант, так как произойдет дублирование кода, который уже существует в классе Human.
Любые обновления в Human также должны быть продублированы и в BasketballPlayer.
---Добавить класс Human в качестве члена в класс BasketballPlayer, используя композицию.
Но возникает вопрос: «Может ли BasketballPlayer иметь Human?». Нет, это некорректно.
---Сделать так, чтобы BasketballPlayer унаследовал необходимые атрибуты от Human.
Помните, что тип отношений в наследовании — «является». Является ли BasketballPlayer Human-ом (т.е. Человеком)?
Конечно! Поэтому наш выбор — наследование.

Делаем класс BasketballPlayer дочерним
Чтобы класс BasketballPlayer унаследовал информацию от класса Human, нам нужно после объявления BasketballPlayer (class BasketballPlayer)
использовать двоеточие, ключевое слово public и имя класса, от которого мы хотим унаследовать. Это называется открытым наследованием:

// BasketballPlayer открыто наследует Human
class BasketballPlayer : public Human
{
public:
    double m_gameAverage;
    int m_points;

    BasketballPlayer(double gameAverage = 0.0, int points = 0)
       : m_gameAverage(gameAverage), m_points(points)
    {
    }
};

Когда BasketballPlayer наследует свойства класса Human, то BasketballPlayer приобретает методы и переменные-члены класса Human.
Кроме того, BasketballPlayer имеет еще два своих собственных члена: m_gameAverage и m_points.
Здесь есть смысл, так как эти свойства специфичны только для BasketballPlayer, а не для каждого Human-а.
Таким образом, объекты BasketballPlayer будут иметь 4 члена:
---m_gameAverage и m_points от BasketballPlayer;
---m_name и m_age от Human.
Полный код программы:
#include <iostream>
#include <string>

class Human
{
public:
    std::string m_name;
    int m_age;

    Human(std::string name = "", int age = 0)
        : m_name(name), m_age(age)
    {
    }

    std::string getName() const { return m_name; }
    int getAge() const { return m_age; }

};

// BasketballPlayer открыто наследует Human
class BasketballPlayer : public Human
{
public:
    double m_gameAverage;
    int m_points;

    BasketballPlayer(double gameAverage = 0.0, int points = 0)
       : m_gameAverage(gameAverage), m_points(points)
    {
    }
};

int main()
{
    // Создаем нового Баскетболиста
    BasketballPlayer anton;
    // Присваиваем ему имя (мы можем делать это напрямую, так как m_name является public)
    anton.m_name = "Anton";
    // Выводим имя Баскетболиста
    std::cout << anton.getName() << '\n'; // используем метод getName(), который мы унаследовали от класса Human

    return 0;
}
Результат выполнения программы:

Anton

Это работает, так как anton является объектом класса BasketballPlayer,
а все объекты класса BasketballPlayer имеют переменную-член m_name и метод getName(), унаследованные от класса Human.

****Множественное наследование*****
Множественное наследование позволяет одному дочернему классу иметь несколько родителей.
Предположим, что мы хотим написать программу для отслеживания работы учителей. Учитель — это Human.
Тем не менее, он также является Сотрудником (Employee).
Множественное наследование может быть использовано для создания класса Teacher, который будет наследовать свойства как Human, так и Employee.
Для использования множественного наследования нужно просто указать через запятую тип наследования и второй родительский класс:
#include <string>

class Human
{
private:
    std::string m_name;
    int m_age;

public:
    Human(std::string name, int age)
        : m_name(name), m_age(age)
    {
    }

    std::string getName() { return m_name; }
    int getAge() { return m_age; }
};

class Employee
{
private:
    std::string m_employer;
    double m_wage;

public:
    Employee(std::string employer, double wage)
        : m_employer(employer), m_wage(wage)
    {
    }

    std::string getEmployer() { return m_employer; }
    double getWage() { return m_wage; }
};

// Класс Teacher открыто наследует свойства классов Human и Employee
class Teacher: public Human, public Employee
{
private:
     int m_teachesGrade;

public:
    Teacher(std::string name, int age, std::string employer, double wage, int teachesGrade)
        : Human(name, age), Employee(employer, wage), m_teachesGrade(teachesGrade)
    {
    }
};

****Полиморфизм*****

Слово полиморфизм означает наличие многих форм. Как правило, полиморфизм возникает, когда существует иерархия классов,
и они связаны наследованием.
Полиморфизм C ++ означает, что вызов функции-члена вызовет выполнение другой функции в зависимости от типа объекта, который вызывает эту функцию.
Рассмотрим следующий пример, когда базовый класс был получен другими двумя классами:
#include <iostream>
using namespace std;

class Shape {
   protected:
      int width, height;

   public:
      Shape( int a = 0, int b = 0){
         width = a;
         height = b;
      }
      int area() {
         cout << "Parent class area :" <<endl;
         return 0;
      }
};
class Rectangle: public Shape {
   public:
      Rectangle( int a = 0, int b = 0):Shape(a, b) { }

      int area () {
         cout << "Rectangle class area :" <<endl;
         return (width * height);
      }
};

class Triangle: public Shape {
   public:
      Triangle( int a = 0, int b = 0):Shape(a, b) { }

      int area () {
         cout << "Triangle class area :" <<endl;
         return (width * height / 2);
      }
};

// Main function for the program
int main() {
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);

   // store the address of Rectangle
   shape = &rec;

   // call rectangle area.
   shape->area();

   // store the address of Triangle
   shape = &tri;

   // call triangle area.
   shape->area();

   return 0;
}
Когда приведенный выше код компилируется и выполняется, он производит следующий результат:
Parent class area :
Parent class area :

Причиной неправильного вывода является то, что вызов функции area() устанавливается один раз компилятором как версия, определенная в базовом классе.
Это называется статическим разрешением вызова функции или статической привязкой - вызов функции фиксируется перед выполнением программы.
Это также иногда называют ранним связыванием, потому что функция area() задается во время компиляции программы.

Но теперь давайте сделаем небольшую модификацию в нашей программе и предваряем объявление area() в классе Shape ключевым словом virtual,
чтобы оно выглядело следующим образом:
class Shape {
   protected:
      int width, height;

   public:
      Shape( int a = 0, int b = 0) {
         width = a;
         height = b;
      }
      virtual int area() {
         cout << "Parent class area :" <<endl;
         return 0;
      }
};
После этой небольшой модификации, когда предыдущий примерный код скомпилирован и выполнен, он производит следующий результат:
Rectangle class area
Triangle class area

На этот раз компилятор просматривает содержимое указателя вместо его типа.
Следовательно, поскольку адреса объектов классов tri и rec хранятся в * форме, вызывается соответствующая функция area().
Как вы можете видеть, каждый из дочерних классов имеет отдельную реализацию для area().
Вот как обычно используется полиморфизм . У вас разные классы с функцией с тем же именем и даже с теми же параметрами, но с разными реализациями.




9)Перегрузка операторов в C++. Операторы вывода в поток.

В языке C++ операторы реализованы в виде функций. Используя перегрузку функции оператора, вы можете определить свои собственные версии операторов,
которые будут работать с разными типами данных (включая классы).
Использование перегрузки функции для перегрузки оператора называется перегрузкой оператора.

Вызов перегруженных операторов
При обработке выражения, содержащего оператор, компилятор использует следующие алгоритмы действий:
---Если все операнды являются фундаментальных типов данных, то вызывать следует встроенные соответствующие версии операторов (если таковые существуют).
Если таковых не существует, то компилятор выдаст ошибку.

---Если какой-либо из операндов является пользовательского типа данных (например, объект класса или типа перечисления),
то компилятор будет искать версию оператора, которая работает с таким типом данных. Если компилятор не найдет ничего подходящего,
то попытается выполнить конвертацию одного или нескольких операндов пользовательского типа данных в фундаментальные типы данных,
чтобы таким образом он мог использовать соответствующий встроенный оператор. Если это не сработает — компилятор выдаст ошибку.

Ограничения в перегрузке операторов
Во-первых, почти любой существующий оператор в языке C++ может быть перегружен. Исключениями являются:

   тернарный оператор (?:);

   оператор sizeof;

   оператор разрешения области видимости (::);

   оператор выбора члена (.);

   указатель, как оператор выбора члена (.*).

****Перегрузка оператора вывода <<****
Для классов с множеством переменных-членов, выводить в консоль каждую переменную по отдельности может быть несколько утомительно.
Например, рассмотрим следующий класс:

class Point
{
private:
    double m_x, m_y, m_z;

public:
    Point(double x=0.0, double y=0.0, double z=0.0): m_x(x), m_y(y), m_z(z)
    {
    }

    double getX() { return m_x; }
    double getY() { return m_y; }
    double getZ() { return m_z; }
};
Если вы захотите вывести объект этого класса на экран, то вам нужно будет сделать что-то вроде следующего:
Point point(3.0, 4.0, 5.0);
std::cout << "Point(" << point.getX() << ", " <<
    point.getY() << ", " <<
    point.getZ() << ")";

А вот если бы мы могли просто написать:
Point point(3.0, 4.0, 5.0);
cout << "My point is: " << point << " in Cartesian space.\n";

И получить тот же результат, но без необходимости разбивать стейтмент вывода на несколько строк и помнить название функции вывода.
К счастью, это можно сделать, перегрузив оператор вывода <<.
Реализация перегрузки оператора << для нашего класса Point довольно-таки проста, так как C++ уже знает, как выводить значения типа double,
а все наши переменные-члены имеют тип double, поэтому мы можем просто использовать оператор << для вывода переменных-членов нашего Point.
Вот класс Point, приведенный выше, но уже с перегруженным оператором <<:
#include <iostream>

class Point
{
private:
    double m_x, m_y, m_z;

public:
    Point(double x=0.0, double y=0.0, double z=0.0): m_x(x), m_y(y), m_z(z)
    {
    }

    friend std::ostream& operator<< (std::ostream &out, const Point &point);
};

std::ostream& operator<< (std::ostream &out, const Point &point)
{
    // Поскольку operator<< является другом класса Point, то мы имеем прямой доступ к членам Point
    out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ")";

    return out;
}

int main()
{
    Point point1(5.0, 6.0, 7.0);

    std::cout << point1;

    return 0;
}

****Перегрузка оператора ввода >>****

Также можно перегрузить и оператор ввода. Всё почти так же, как и с оператором вывода, но главное,
что нужно помнить — std::cin является объектом типа std::istream.
Вот наш класс Point с перегруженным оператором ввода >>:
#include <iostream>

class Point
{
private:
    double m_x, m_y, m_z;

public:
    Point(double x=0.0, double y=0.0, double z=0.0): m_x(x), m_y(y), m_z(z)
    {
    }

    friend std::ostream& operator<< (std::ostream &out, const Point &point);
    friend std::istream& operator>> (std::istream &in, Point &point);
};

std::ostream& operator<< (std::ostream &out, const Point &point)
{
    // Поскольку operator<< является другом класса Point, то мы имеем прямой доступ к членам Point
    out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ")";

    return out;
}

std::istream& operator>> (std::istream &in, Point &point)
{
    // Поскольку operator>> является другом класса Point, то мы имеем прямой доступ к членам Point.
    // Обратите внимание, параметр point (объект класса Point) должен быть неконстантным, чтобы мы имели возможность изменить члены класса
    in >> point.m_x;
    in >> point.m_y;
    in >> point.m_z;

    return in;
}



10)Перегрузка операторов в C++. Оператор присваивания. Арифметические операторы.

****Перегрузка оператора присваивания (=)***
#include <iostream>
#include <cassert>

class Drob
{
private:
	int m_numerator;
	int m_denominator;

public:
    // Конструктор по умолчанию
    Drob(int numerator=0, int denominator=1) :
        m_numerator(numerator), m_denominator(denominator)
    {
        assert(denominator != 0);
    }

	// Конструктор копирования
	Drob(const Drob &copy) :
		m_numerator(copy.m_numerator), m_denominator(copy.m_denominator)
	{
		// Нет необходимости выполнять проверку denominator здесь, так как эта проверка уже осуществлена в конструкторе по умолчанию
		std::cout << "Copy constructor worked here!\n"; // просто, чтобы показать, что это работает
	}

        // Перегрузка оператора присваивания
        Drob& operator= (const Drob &drob)
        {
             // Выполняем копирование значений
             m_numerator = drob.m_numerator;
             m_denominator = drob.m_denominator;

             // Возвращаем текущий объект, чтобы иметь возможность связать в цепочку выполнение нескольких операций присваивания
             return *this;
        }

	friend std::ostream& operator<<(std::ostream& out, const Drob &d1);

};

std::ostream& operator<<(std::ostream& out, const Drob &d1)
{
	out << d1.m_numerator << "/" << d1.m_denominator;
	return out;
}

int main()
{
    Drob sixSeven(6, 7);
    Drob d;
    d = sixSeven; // вызывается перегруженный оператор присваивания
    std::cout << d;

    return 0;
}
Результат выполнения программы:

6/7

****Арифметические операторы****
Рассмотрим унарные операторы плюс (+), минус (-) и логическое НЕ (!), которые работают с одним операндом.
Так как они применяются только к одному объекту, то их перегрузку следует выполнять через методы класса.

Например, перегрузим унарный оператор минус (-) для класса Dollars:
#include <iostream>

class Dollars
{
private:
    int m_dollars;

public:
    Dollars(int dollars) { m_dollars = dollars; }

    // Выполняем -Dollars через метод класса
    Dollars operator-() const;

    int getDollars() const { return m_dollars; }
};

// Эта функция является методом класса!
Dollars Dollars::operator-() const
{
    return Dollars(-m_dollars);
}

int main()
{
    const Dollars dollars1(7);
    std::cout << "My debt is " << (-dollars1).getDollars() << " dollars.\n";

    return 0;
}
Всё довольно-таки просто. Перегрузка отрицательного унарного оператора минус (-) осуществляется через метод класса,
так как явные параметры в функции перегрузки отсутствуют (только неявный объект, на который указывает скрытый указатель *this).
Оператор - возвращает объект Dollars с отрицательным значением m_dollars. Поскольку этот оператор не изменяет объект класса Dollars,
то мы можем (и должны) сделать функцию перегрузки константной (чтобы иметь возможность использовать этот оператор и с константными объектами класса Dollars).




11)Потоки ввода вывода в stl

Абстрактно, поток — это последовательность символов, к которым можно получить доступ.
Со временем поток может производить или потреблять потенциально неограниченные объемы данных.
Мы будем иметь дело с двумя типами потоков. Поток ввода (или «входной поток») используется для хранения данных,
полученных от источника данных: клавиатуры, файла, сети и т.д. Например, пользователь может нажать клавишу на клавиатуре в то время,
когда программа не ожидает ввода. Вместо игнорирования нажатия клавиши, данные помещаются во входной поток, где затем ожидают ответа от программы.
И наоборот, поток вывода (или «выходной поток») используется для хранения данных, предоставляемых конкретному потребителю данных: монитору, файлу, принтеру и т.д.
При записи данных на устройство вывода, это устройство может быть не готовым принять данные немедленно.
Например, принтер все еще может прогреваться, когда программа уже записывает данные в выходной поток.
Таким образом, данные будут находиться в потоке вывода до тех пор, пока принтер не начнет их использовать.
Некоторые устройства, такие как файлы и сети, могут быть источниками как ввода, так и вывода данных.

Класс istream используется для работы с входными потоками. Оператор извлечения >> используется для извлечения значений из потока.
Это имеет смысл: когда пользователь нажимает на клавишу клавиатуры, код этой клавиши помещается во входной поток.
Затем программа извлекает это значение из потока и использует его.

Класс ostream используется для работы с выходными потоками. Оператор вставки << используется для помещения значений в поток.
Это также имеет смысл: вы вставляете свои значения в поток, а затем потребитель данных (например, монитор) использует их.

Класс iostream может обрабатывать как ввод, так и вывод данных, что позволяет ему осуществлять двунаправленный ввод/вывод.

*****Стандартные потоки в C++****
Стандартный поток — это предварительно подключенный поток, который предоставляется программе её окружением.
Язык C++ поставляется с 4-мя предварительно определенными стандартными объектами потоков, которые вы можете использовать (первые три вы уже встречали):
---cin — класс istream_withassign, связанный со стандартным вводом (обычно это клавиатура);
---cout — класс ostream_withassign, связанный со стандартным выводом (обычно это монитор);
---cerr — класс ostream_withassign, связанный со стандартной ошибкой (обычно это монитор), обеспечивающий небуферизованный вывод;
---clog — класс ostream_withassign, связанный со стандартной ошибкой (обычно это монитор), обеспечивающий буферизованный вывод.

Небуферизованный вывод обычно обрабатывается сразу же, тогда как буферизованный вывод обычно сохраняется и выводится как блок.
Поскольку clog используется редко, то его обычно игнорируют.

Вот пример использования ввода/вывода данных со стандартными потоками:
#include <iostream>
#include <cstdlib> // для exit()

int main()
{
    // Сначала мы используем оператор вставки с объектом cout для вывода текста на монитор
    std::cout << "Enter your age: " << std::endl;

    // Затем мы используем оператор извлечения с объектом cin для получения пользовательского ввода
    int nAge;
    std::cin >> nAge;

    if (nAge <= 0)
    {
        // В этом случае мы используем оператор вставки с объектом cerr для вывода сообщения об ошибке
        std::cerr << "Oops, you entered an invalid age!" << std::endl;
        exit(1);
    }

    // А здесь мы используем оператор вставки с объектом cout для вывода результата
    std::cout << "You entered " << nAge << " years old" << std::endl;

    return 0;
}





12)Потоки и параллельное выполнение в стандартной библиотеке С++11/14





13)Преобразование типов в C++. Явное и неявное преобразование типов.

В языке C++ есть 5 видов операций явного преобразования типов:

---конвертация C-style;
---применение оператора static_cast;
---применение оператора const_cast;
---применение оператора dynamic_cast;
---применение оператора reinterpret_cast.

****Конвертация C-style****

В программировании на языке Cи явное преобразование типов данных выполняется с помощью оператора ().
Внутри круглых скобок мы пишем тип, в который нужно конвертировать. Этот способ конвертации типов называется конвертацией C-style. Например:

int i1 = 11;
int i2 = 3;
float x = (float)i1 / i2;

В программе, приведенной выше, мы используем круглые скобки, чтобы сообщить компилятору о необходимости преобразования переменной i1 (типа int) в тип float.
Поскольку переменная i1 станет типа float, то i2 также затем автоматически преобразуется в тип float, и выполнится деление типа с плавающей точкой.

*****Оператор static_cast*****
В языке C++ есть еще один оператор явного преобразования типов данных — оператор static_cast.

char c = 97;
std::cout << static_cast<int>(c) << std::endl; // в результате выведется 97, а не 'a'

Оператор static_cast лучше всего использовать для конвертации одного фундаментального типа данных в другой:

int i1 = 11;
int i2 = 3;
float x = static_cast<float>(i1) / i2;

*****Неявное преобразование типов*****

Неявное преобразование типов (или «автоматическое преобразование типов») выполняется всякий раз, когда требуется один фундаментальный тип данных,
но предоставляется другой, и пользователь не указывает компилятору, как выполнить конвертацию (не использует явное преобразование типов через операторы явного преобразования).

Есть 2 основных способа неявного преобразования типов:
---числовое расширение;
---числовая конверсия.

Числовое расширение
Когда значение из одного типа данных конвертируется в другой тип данных побольше (по размеру и по диапазону значений), то это называется числовым расширением.
Например, тип int может быть расширен в тип long, а тип float может быть расширен в тип double:
long l(65); // расширяем значение типа int (65) в тип long
double d(0.11f); // расширяем значение типа float (0.11) в тип double

****Числовые конверсии****

Когда мы конвертируем значение из более крупного типа данных в аналогичный,
но более мелкий тип данных, или конвертация происходит между разными типами данных, то это называется числовой конверсией. Например:
double d = 4; // конвертируем 4 (тип int) в double
short s = 3; // конвертируем 3 (тип int) в short
В отличие от расширений, которые всегда безопасны, конверсии могут (но не всегда) привести к потере данных.
Поэтому в любой программе, где выполняется неявная конверсия, компилятор будет выдавать предупреждение.





14)Проектирование программ - инкапсуляция.

В объектно-ориентированном программировании инкапсуляция (или «сокрытие информации») — это процесс скрытого хранения деталей реализации объекта.
Пользователи обращаются к объекту через открытый интерфейс.

В языке C++ инкапсуляция реализована через спецификаторы доступа. Как правило, все переменные-члены класса являются закрытыми (скрывая детали реализации),
а большинство методов являются открытыми (с открытым интерфейсом для пользователя).
Хотя требование к пользователям использовать публичный интерфейс может показаться более обременительным, нежели просто открыть доступ к переменным-членам,
но на самом деле это предоставляет большое количество полезных преимуществ, которые улучшают возможность повторного использования кода и его поддержку.

Преимущество №1: Инкапсулированные классы проще в использовании и уменьшают сложность ваших программ.

С полностью инкапсулированным классом вам нужно знать только то, какие методы являются доступными для использования,
какие аргументы они принимают и какие значения возвращают. Не нужно знать, как класс реализован изнутри. Например, класс, содержащий список имен,
может быть реализован с использованием динамического массива, строк C-style, std::array, std::vector, std::map, std::list или любой другой структуры данных.
Для использования этого класса, вам не нужно знать детали его реализации. Это значительно снижает сложность ваших программ,
а также уменьшает количество возможных ошибок. Это является ключевым преимуществом инкапсуляции.

Преимущество №2: Инкапсулированные классы помогают защитить ваши данные и предотвращают их неправильное использование.

Преимущество №3: Инкапсулированные классы легче изменить.




15)Пространства имен. Области видимости в C++.

Пространство имен определяет область кода, в которой гарантируется уникальность всех идентификаторов.
По умолчанию, глобальные переменные и обычные функции определены в глобальном пространстве имен. Например:

int g_z = 4;

int boo(int z)
{
    return -z;
}

Глобальная переменная g_z и функция boo() определены в глобальном пространстве имен.

В примере, приведенном выше, при подключении файлов boo.h и doo.h обе версии doOperation() были включены в глобальное пространство имен,
из-за чего, собственно, и произошел конфликт имен.

Чтобы избежать подобных ситуаций, когда два независимых объекта имеют идентификаторы, которые могут конфликтовать друг с другом при совместном использовании,
язык C++ позволяет объявлять собственные пространства имен через ключевое слово namespace.
Всё, что объявлено внутри пользовательского пространства имен, — принадлежит только этому пространству имен (а не глобальному).

Область видимости переменных — это те части программы, в которой пользователь может изменять или использовать переменные в своих нуждах.

В C++ существуют отдельные блоки, которые начинаются с открывающей скобки ({) и заканчиваются соответственно закрывающей скобкой (}).
Такими блоками являются циклы (for, while, do while) и функции.

int func () {
    // блок (функция - func)
}

int main() {
    // блок (функция - main)
    for (int i = 0; i < 10; i++) {
        // блок (цикл - for), также является дочерним блоком функции main
        for (int j = 0; j < 5; j++) {
          // блок (цикл - for), но он еще является и дочерним блоком для первого цикла
        }
    }


    system("pause");
    return 0;

Если переменная была создана в таком блоке, то ее областью видимости будет являться этот блок от его начала
(от открывающей скобки —  { ) и до его конца (до закрывающей скобки — } ) включая все дочерние блоки созданные в этом блоке.
В примере ниже, программист ошибся с областью видимости:
Он создал переменную j во втором цикле.
Использовав ее в первом цикле for он вынудил компилятор сообщить об ошибке (переменной j больше нет, поскольку второй цикл закончил свою работу).
    int main() {

        for (int i = 0; i < 10; i++) {
            int b = i;
            for (int j = 0; j < 5; j++) {
                cout << b + j;
            }
            cout << j;  // ошибка: так как переменная j была создана в другом блоке
        }

        system("pause");
        return 0;
    }

А вот ошибки в строке 6 нет, поскольку второй цикл находится в первом цикле (является дочерним блоком первого цикла)  и поэтому переменная b может спокойно там использоваться.

*****Глобальные переменные в C++*****
Глобальными переменными называются те переменные, которые были созданы вне тела какого-то блока.
Их можно всегда использовать во всей вашей программе, вплоть до ее окончания работы. В примере ниже мы создали две глобальные переменные global и global_too и использовали их в функции summa:

    int global = 5;       // глобальные
    int global_too = 10;  // переменные

    int summa() {
        cout << global + global_too;  // суммируем числа
    }

    int main() {
        summa();  // вызываем функцию summa

        system("pause");
        return 0;
    }

****Локальные переменные****
Локальные переменные — это переменные созданные в блоках. Областью видимости таких переменных является блоки ( и все их дочерние ),
а также их область видимости не распространяется на другие блоки. Как ни как, но эти переменные созданы в отдельных блоках.
Из этого можно сделать вывод: у нас есть возможность создавать переменные с одинаковыми именами,
но в разных блоках (или другими словами, чтобы их область видимости не совпадала друг с другом).

int main() {
    for (int i = 0; i < 2; i++) {
      int b = i;  // локальная переменная (она находится в блоке for)
      cout << b;
    }
    system("pause");
    return 0;
}
В примере выше блоком где была создана локальная переменная b является цикл for (2 — 5).
А вот если бы мы захотели вывести переменную b вне блока for, компилятор сообщил бы нам об ошибке.



16)Расширения языка C++11. Auto. Nultr. Рендж базед циклы

****Auto****

До С++11, ключевое слово auto использовалось как спецификатор хранения переменной (как, например, register, static, extern).
В С++11 auto позволяет не указывать тип переменной явно, говоря компилятору, чтобы он сам определил фактический тип переменной,
на основе типа инициализируемого значения. Это может использоваться при объявлении переменных в различных областях видимости,
как, например, пространство имен, блоки, инициализация в цикле и т.п.
auto i = 42;        // i - int
auto l = 42LL;      // l - long long
auto p = new foo(); // p - foo*

Использование auto позволяет сократить код (если, конечно, тип не int, который на одну букву меньше).
Подумайте об итераторах STL, которые вы должны были всегда писать для прохода контейнеров.
Таким образом, это делает устаревшим определение typedef только ради простоты.

****nullptr****

Раньше, для обнуления указателей использовался макрос NULL, являющийся нулем — целым типом, что, естественно,
вызывало проблемы (например, при перегрузке функций). Ключевое слово nullptr имеет свой собственный тип std::nullptr_t,
что избавляет нас от бывших проблем. Существуют неявные преобразования nullptr к нулевому указателю любого типа и к bool (как false),
но преобразования к целочисленных типам нет.
void foo(int* p) {}

void bar(std::shared_ptr<int> p) {}

int* p1 = NULL;
int* p2 = nullptr;

if(p1 == p2)
{}

foo(nullptr);
bar(nullptr);

bool f = nullptr;
int i = nullptr; // ошибка: для преобразования в int надо использовать reinterpret_cast

****range-based циклы****

В С++11 была добавлена поддержка парадигмы foreach для итерации по набору.
В новой форме возможно выполнять итерации в случае, если для объекта итерации перегружены методы begin() и end().
Это полезно, когда вы просто хотите получить элементы массива/контейнера или сделать с ними что-то, не заботясь об индексах, итераторах или кол-ве элементов.
std::map<std::string, std::vector<int>> map;
std::vector<int> v;
v.push_back(1);
v.push_back(2);
v.push_back(3);
map["one"] = v;

for(const auto &kvp: map)
{
   std::cout << kvp.first << std::endl;
   for(auto v: kvp.second)
      std::cout << v << std::endl;
}

int arr[] = {1,2,3,4,5};

for(int &e: arr)
   e *= e;




17)Темплейты. Пример шаблонной функции.

В языке C++ шаблоны функций — это функции, которые служат образцом для создания других подобных функций.
Главная идея — создание функций без указания точного типа(ов) некоторых или всех переменных.
Для этого мы определяем функцию, указывая тип параметра шаблона, который используется вместо любого типа данных.
После того, как мы создали функцию с типом параметра шаблона, мы фактически создали «трафарет функции».

При вызове шаблона функции, компилятор использует «трафарет» в качестве образца функции, заменяя тип параметра шаблона на фактический тип переменных,
передаваемых в функцию! Таким образом, мы можем создать 50 «оттенков» функции, используя всего лишь один шаблон!

****Создание шаблонов функций****

Сейчас вам, вероятно, интересно, как создаются шаблоны функций в языке C++.
 Оказывается, это не так уж и сложно. Рассмотрим еще раз целочисленную версию функции max():

int max(int a, int b)
{
    return (a > b) ? a : b;
}

Здесь мы трижды указываем тип данных: в параметрах a, b и в типе возврата функции.
Для создания шаблона этой функции нам нужно заменить тип int на тип параметра шаблона функции.
Поскольку в этом случае используется только один тип данных (int), то нам нужно указать только один тип параметра шаблона.

Мы можем назвать этот тип как угодно, главное, чтобы это не было зарезервированным/ключевым словом.
В языке C++ принято называть типы параметров шаблонов большой буквой T (сокр. от Type).
Вот наша переделанная функция max():

T max(T a, T b)
{
    return (a > b) ? a : b;
}

Но это еще не всё. Программа работать не будет, так как компилятор не знает, что такое Т!
Чтобы всё заработало, нам нужно сообщить компилятору две вещи:
---Определение шаблона функции.
---Указание того, что T является типом параметра шаблона функции.
Мы можем сделать это в одной строке кода, выполнив объявление шаблона (а точнее — объявление параметров шаблона):

template <typename T> // объявление параметра шаблона функции
T max(T a, T b)
{
    return (a > b) ? a : b;
}

Рассмотрим детально объявление параметров шаблона:
---Сначала пишем ключевое слово template, которое сообщает компилятору, что дальше мы будем объявлять параметры шаблона.
---Параметры шаблона функции указываются в угловых скобках (<>).
---Для создания типов параметров шаблона используются ключевые слова typename и class.
В базовых случаях использования шаблонов функций разницы между typename и class нет, поэтому вы можете выбрать любое из двух.
Если вы используете ключевое слово class, то фактический тип параметров не обязательно должен быть классом
(это может быть переменная фундаментального типа данных, указатель или что-то другое).
---Затем называем тип параметра шаблона (обычно T).

Если требуется несколько типов параметров шаблона, то они разделяются запятыми:

template <typename T1, typename T2>
// Шаблон функции здесь

Если параметров несколько, то их обычно называют T1, T2 или другими буквами: T, S.

****Использование шаблонов функций****

Использование шаблонов функций аналогично использованию обычных функций:
#include <iostream>

template <typename T>
const T& max(const T& a, const T& b)
{
    return (a > b) ? a : b;
}

int main()
{
    int i = max(4, 8);
    std::cout << i << '\n';

    double d = max(7.56, 21.434);
    std::cout << d << '\n';

    char ch = max('b', '9');
    std::cout << ch << '\n';

    return 0;
}
Результат:
8
21.434
b





18)Темплейты. Пример шаблонного класса

Любой шаблон начинается со слова template, будь то шаблон функции или шаблон класса.
После  ключевого слова template идут угловые скобки — < >, в которых перечисляется список параметров шаблона.
Каждому параметру должно предшествовать зарезервированное слово class или typename.
Отсутствие этих ключевых слов будет расцениваться компилятором как синтаксическая ошибка. Некоторые примеры объявления шаблонов:
template <class T>

Ключевое слово typename говорит о том, что в шаблоне будет использоваться встроенный тип данных, такой как: int, double,float, char и т. д.
А ключевое слово class сообщает компилятору, что в шаблоне функции в качестве параметра будут использоваться пользовательские типы данных,
то есть классы. Но не в коем случае не путайте параметр шаблона и шаблон класса. Если нам надо создать шаблон класса,
с одним параметром типа int и char, шаблон класса будет выглядеть так:
template <typename T>
class Name
{
//тело шаблона класса
};

где T — это параметр шаблона класса, который может принимать любой из встроенных типов данных, то, что нам и нужно.

А если параметр шаблона класса должен пользовательского типа, например типа Array, где Array — это класс,
описывающий массив, шаблон класса будет иметь следующий вид:

template <class T>
class Name
{
//тело шаблона класса
};




19)Указатели на функции и их использование совместно с массивами и структурами.




20)Умные указатели в библиотеке stl.

Умный указатель — это класс, предназначенный для управления динамически выделенной памятью и обеспечения освобождения (удаления) выделенной памяти
при выходе объекта этого класса из области видимости. Соответственно, встроенные (обычные) указатели иногда еще называют «глупыми указателями»,
так как они не могут выполнять после себя очистку памяти.

Теперь вернемся к нашему примеру с myFunction() и покажем, как использование класса умного указателя сможет решить нашу проблему:

#include <iostream>

template<class T>
class Auto_ptr1
{
	T* m_ptr;
public:
	// Получаем указатель для "владения" через конструктор
	Auto_ptr1(T* ptr=nullptr)
		:m_ptr(ptr)
	{
	}

	// Деструктор позаботится об удалении указателя
	~Auto_ptr1()
	{
		delete m_ptr;
	}

	// Выполняем перегрузку оператора разыменования и оператора ->, чтобы иметь возможность использовать Auto_ptr1 как m_ptr
	T& operator*() const { return *m_ptr; }
	T* operator->() const { return m_ptr; }
};

// Класс для проверки работоспособности вышеприведенного кода
class Item
{
public:
    Item() { std::cout << "Item acquired\n"; }
    ~Item() { std::cout << "Item destroyed\n"; }
    void sayHi() { std::cout << "Hi!\n"; }
};

void myFunction()
{
    Auto_ptr1<Item> ptr(new Item); // ptr теперь "владеет" Item-ом

    int a;
    std::cout << "Enter an integer: ";
    std::cin >> a;

    if (a == 0)
        return; // досрочный возврат функции

    // Использование ptr
    ptr->sayHi();
}

int main()
{
    myFunction();

    return 0;
}
Если пользователь введет ненулевое целое число, то результат выполнения программы:

Item acquired
Enter an integer: 7
Hi!
Item destroyed

Если же пользователь введет ноль, то функция myFunction() завершит свое выполнение досрочно, и мы увидим:

Item acquired
Enter an integer: 0
Item destroyed





21)Функции. Передача параметров. По значению. По ссылке. По указателю. Использование const с параметрами.

****Функции****

Функция — это последовательность стейтментов для выполнения определенного задания.
Часто ваши программы будут прерывать выполнение одних функций ради выполнения других. Вы делаете аналогичные вещи в реальной жизни постоянно.
Например, вы читаете книгу и вспомнили, что должны были сделать телефонный звонок. Вы оставляете закладку в своей книге, берете телефон и набираете номер.
После того, как вы уже поговорили, вы возвращаетесь к чтению: к той странице, на которой остановились.

Программы на языке C++ работают похожим образом. Иногда, когда программа выполняет код, она может столкнуться с вызовом функции.
Вызов функции — это выражение, которое указывает процессору прервать выполнение текущей функции и приступить к выполнению другой функции.
Процессор «оставляет закладку» в текущей точке выполнения, а затем выполняет вызываемую функцию. Когда выполнение вызываемой функции завершено,
процессор возвращается к закладке и возобновляет выполнение прерванной функции.

Функция, в которой находится вызов, называется caller, а функция, которую вызывают — вызываемая функция, например:

#include <iostream> // для std::cout и std::endl

// Объявление функции doPrint(), которую мы будем вызывать
void doPrint() {
   std::cout << "In doPrint()" << std::endl;
}

// Объявление функции main()
int main()
{
   std::cout << "Starting main()" << std::endl;
   doPrint(); // прерываем выполнение функции main() вызовом функции doPrint(). Функция main() в данном случае является caller-ом
   std::cout << "Ending main()" << std::endl;
   return 0;
}
Результат выполнения программы:

Starting main()
In doPrint()
Ending main()

****Параметр****
Параметр функции (или «формальный параметр») — это переменная, создаваемая в объявлении функции:

void boo(int x); // объявление (прототип функции). x - это параметр

void boo(int x) // определение (также объявление). x - это параметр
{
}
Аргумент (или «фактический параметр») — это значение, которое передает в функцию вызывающий объект (caller):

boo(7); // 7 - это аргумент, который передается в параметр x
boo(y+1); // выражение y+1 - это аргумент, который передается в параметр x

Когда функция вызывается, все параметры функции создаются как переменные, а значения аргументов копируются в параметры. Например:
void boo(int x, int y)
{
}

boo(4, 5);

*****По значению****
По умолчанию, аргументы в C++ передаются по значению. Когда аргумент передается по значению, то его значение копируется в параметр функции. Например:

#include <iostream>

void boo(int y)
{
    std::cout << "y = " << y << std::endl;
}

int main()
{
    boo(7); // 1-й вызов

    int x = 8;
    boo(x); // 2-й вызов
    boo(x + 2); // 3-й вызов

    return 0;
}
Таким образом, результат выполнения программы:

y = 7
y = 8
y = 10

****По ссылке****
При передаче переменной по ссылке нужно просто объявить параметры функции как ссылки, а не как обычные переменные:

void func(int &x) // x - это переменная-ссылка
{
    x = x + 1;
}

При вызове функции переменная x станет ссылкой на аргумент. Поскольку ссылка на переменную обрабатывается точно так же,
как и сама переменная, то любые изменения, внесенные в ссылку, приведут к изменениям исходного значения аргумента!
В следующем примере это хорошо проиллюстрировано:

#include <iostream>

void boo(int &value)
{
    value = 7;
}

int main()
{
    int value = 6;

    std::cout << "value = " << value << '\n';
    boo(value);
    std::cout << "value = " << value << '\n';
    return 0;
}

Эта программа точно такая же, как и программа из предыдущего урока, за исключением того,
что параметром функции boo() теперь является ссылка вместо обычной переменной.

Результат выполнения программы:

value = 6
value = 7

Передача по константной ссылке
Одним из самых главных недостатков передачи по значению является то, что все аргументы, переданные по значению, копируются в параметры функции.
Когда аргументами являются большие структуры или классы, то этот процесс может занять много времени.
В случае с передачей по ссылке эта проблема легко решается. Когда аргумент передается по ссылке,
то создается ссылка на фактический аргумент (что занимает минимальное количество времени на выполнение), и никакого копирования значений не происходит.
Это позволяет передавать большие структуры или классы с минимальной затратой ресурсов.

Однако здесь также могут возникнуть потенциальные проблемы.
Ссылки позволяют функции изменять значения аргументов напрямую, что нежелательно, если мы хотим, чтобы аргумент был доступен только для чтения.
Когда мы знаем, что функция не должна изменять значение аргумента, но не хотим использовать передачу по значению,
то лучшим решением будет использовать передачу по константной ссылке.

Вы уже знаете, что константная ссылка — это ссылка на переменную, значение которой изменить через эту же ссылку не получится никак.
Следовательно, если мы используем константную ссылку в качестве параметра, то получаем 100% гарантию того, что функция не изменит аргумент!

Запустив следующий фрагмент кода, мы получим ошибку компиляции:

void boo(const int &y) // y - это константная ссылка
{
    y = 8; // ошибка компиляции: константная ссылка не может изменить свое же значение!
}

Использование const полезно по нескольким причинам:
---Мы получаем гарантию от компилятора, что значения, которые не должны быть изменены — не изменятся
(компилятор выдаст ошибку, если мы попытаемся сделать нечто подобное тому, что было в вышеприведенном примере).
---Программист, видя const, понимает, что функция не изменит значение аргумента.
Это может помочь при отладке программы.
---Мы не можем передать константный аргумент в неконстантную ссылку-параметр.
 Использование константного параметра гарантирует, что мы сможем передавать как неконстантные, так и константные аргументы в функцию.
---Константные ссылки могут принимать любые типы аргументов, включая l-values, константные l-values ​​и r-values.
Правило: При передаче аргументов по ссылке всегда используйте константные ссылки, если вам не нужно, чтобы функция изменяла значения аргументов.

****По указателю****

Передача аргументов по адресу — это передача адреса переменной-аргумента (а не исходной переменной).
 Поскольку аргумент является адресом, то параметром функции должен быть указатель.
 Затем функция сможет разыменовать этот указатель для доступа или изменения исходного значения.
 Вот пример функции, которая принимает параметр, передаваемый по адресу:

#include <iostream>

void boo(int *ptr)
{
    *ptr = 7;
}

int main()
{
    int value = 4;

    std::cout << "value = " << value << '\n';
    boo(&value);
    std::cout << "value = " << value << '\n';
    return 0;
}

Результат выполнения программы:

value = 4
value = 7





22) lvalue и rvalue. Move семантика.

****l-values и r-values****
Несмотря на то, что в обоих терминах есть слово «value» (значение), l-values и r-values на самом деле являются не свойствами значений,
а скорее свойствами выражений.
Каждое выражение в языке C++ имеет два свойства: тип и категорию значения (определяет, можно ли результат выражения присвоить другому объекту).
В C++03 и в более ранних версиях С++ l-values ​​и r-values ​​были единственными категориями значений.
О l-value проще всего думать, как о функции, объекте или переменной (или выражении, результатом которого является функция, объект или переменная),
которая имеет свой адрес памяти. Изначально l-values были определены как «значения, которые должны находиться в левой части операции присваивания».
Однако позже в язык С++ было добавлено ключевое слово const, и l-values были разделены на две подкатегории:
---Модифицируемые l-values, которые можно изменить (например, переменной x можно присвоить другое значение).
---Немодифицируемые l-values, которые являются const (например, константа PI).
О r-value проще всего думать, как «обо всем остальном, что не является l-value».
Это литералы (например, 5), временные значения (например, x + 1) и анонимные объекты (например, Fraction(7, 3)).
r-values имеют область видимости выражения (уничтожаются в конце выражения, в котором находятся) и им нельзя что-либо присвоить.
Этот запрет на присваивание имеет смысл, так как присваивая значение мы вызываем в объекта побочные эффекты.
А поскольку r-values имеют область видимости выражения, то, если бы мы присваивали какое-либо значение для r-value,
r-value либо выходило бы из области видимости, прежде чем у нас была бы возможность использовать присвоенное значение в следующем выражении
(что делает операцию присваивания бесполезной), либо нам пришлось бы использовать переменную с побочным эффектом, который возникал
бы больше одного раза в выражении (что, как вы уже должны знать, привело бы к неопределенным результатам!).

****Move семантика****
Move семантика позволяет переместить объект вместо его копирования для увеличения производительности.
Проще всего понять семантику перемещения на примере. В качестве этого примера будет использоваться класс String:

class String
{
public:
    explicit String(const char *const c_string)
    {
        std::cout << "String(const char *const c_string)\n";
        size = strlen(c_string) + 1;
        this->c_string = new char[size];
        strcpy(this->c_string, c_string);
    }

    String(const String& other)
    {
        std::cout << "String(const String& other)\n";
        c_string = new char[other.size];
        strcpy(c_string, other.c_string);
        size = other.size;
    }

    ~String() noexcept
    {
        std::cout << "~String()\n";
        delete[] c_string; // delete на nullptr не даёт никакого эффекта
    }

private:
    char *c_string;
    size_t size;
};
